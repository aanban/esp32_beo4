#ifndef IRBEO4_H_
#define IRBEO4_H_

#include "Arduino.h"

// external call back functions
extern __attribute__((weak)) void beo_code_cb(uint32_t beo_code);
extern __attribute__((weak)) void beo_led_cb(uint8_t mode);

// states Beo4 receicver state machine
enum class bState { Idle, S0, S1, Start, Data, Stop };

// timeout values, 20ms or infinite
constexpr TickType_t WAIT_infi = portMAX_DELAY;  
constexpr TickType_t WAIT_20ms = (20/portTICK_PERIOD_MS);

// interupt-serice-routine
// triggers on rising edge of IR signal, get timestamp and put to q_irs_queue 
void IRAM_ATTR ir_pulse_isr(void);

// internal callback function for one-shot-timer
void IRAM_ATTR one_shot_timer_cb(void* arg);

class IrBeo4 {
  private:
    int8_t     m_rx_pin  = -1;           // IR receive pin
    int8_t     m_tx_pin  = -1;           // IR transmit pin
    int8_t     m_tx_pwm  = -1;           // IR transmit pwm channel
    int64_t    m_tsFrm   = 0;            // timestamp frame start
    int64_t    m_tsNew   = 0;            // timestamp new edge arrived
    int64_t    m_tsPre   = 0;            // timestamp previous edge
    uint8_t    m_bc      = 0;            // data bit counter 0..16
    uint8_t    m_preBit  = 0;            // previous bit code
    uint8_t    m_pCode   = 0;            // pulse code
    uint32_t   m_pWidth  = 0;            // pulse width 
    uint32_t   m_beoCode = 0;            // decoded Beo4 code
    bState     m_rxFSM   = bState::Idle; // initial state receive statemachine
    TickType_t m_wait    = WAIT_infi;    // initial timeout reading isr-queue

    QueueHandle_t m_beo4_rx_queue;       // output queue for received beoCodes
    QueueHandle_t m_beo4_tx_queue;       // input queue for beoCodes to be send
    esp_timer_handle_t m_OneShotTimer_h; // ont-shot-timer handle 
    
    //  Beo4 receiver state machine
    //  gets timestamps from ISR-queue, computes PulseWith and converts to 
    //  PulseCode=(PulseWidth+1562)/3125. The first queue access is made waiting 
    //  infinite. The subsequent reads are done with a 20 ms timeout. This is 
    //  done because the TSOP7000 replica sometimes produces dummy pulses.
    //  @param tsNew = timestamp of received rising edge
    void RxFsm(int64_t tsNew);
    
    // reset receive state machine
    // - print logmessage
    // - set timeout to infinite 
    // - set state to idle
    // - turn LED off
    inline void ResetRxFSM(const char* str_log) {
      log_i("%s: t=%lld fsm=%d pc=%d \n",str_log,m_tsNew,m_rxFSM,m_pCode);
      m_wait=WAIT_infi;  
      m_rxFSM=bState::Idle;
      if(beo_led_cb) {
        beo_led_cb(HIGH); // turn LED off
      }
    }
    
    // get timeout value
    // @return TickType_t m_wait = WAIT_infi or WAIT_20ms
    inline TickType_t get_wait(void){
      return this->m_wait;
    }

    // Beo4 Receive Task, reads timestamps from ISR queue and call state-machine 
    // decoding start, data and stop codes. 
    // @param param = handle to the class
    friend void beo4_rx_task(void *param); 
    TaskHandle_t m_beo4_rx_task; // task handle
    
    // Beo4 Transmit Task, reads beoCode from m_queue_beo_tx. The 455kHz
    // carrier is generted by a PWM channel that is attached to m_ir_tx_pin 
    // (ledcSetup(),ledcAttachPin(),ledcWrite()). The Pulses are generated by 
    // setting the PWM-channel's duty-cycle, i.e. ledcWrite(channel,0)=pause
    // ledcWrite(channel,7)=carrier-burst. Start/stop pulses are added to 
    // complete the frame. 
    // @param handle = handle to the class
    friend void beo4_tx_task(void *handle); 
    TaskHandle_t m_beo4_tx_task; // task handle

  protected:
  public:
    // constructor
    // @param rx_pin  = IR receiver input pin
    // @param tx_pin  = IR transmit output pin (default=-1, not used)
    // @param tx_pwm  = IR transmit pwm-channel (default=-1, not used)
    IrBeo4(int8_t rx_pin,int8_t tx_pin=-1, int8_t tx_pwm=-1);
    
    // destructor
    ~IrBeo4();

    // attach the interrupt service routine to the rx_pin, and trigger by
    // rising edge. Start tasks for receive and transmit
    // @param beo4_rx_queue = queue for received beo4-codes
    // @param beo4_tx_queue = queue for beo4-codes to be transmitted
    // @return 0=OK, -1=Failed
    int Begin(QueueHandle_t beo4_rx_queue, QueueHandle_t beo4_tx_queue=NULL);

};
#endif /* IRBEO4_H_ */
